vunit i_cache_cntrl(cache_cntrl(Behavioral))
{
   default clock is rising_edge(aclk);

   signal f_prev_valid: Boolean := false;

   process(aclk)
   begin
	if rising_edge(aclk) then
	   f_prev_valid <= true;
	end if;
   end process;

   signal f_addr: std_logic_vector(cpu_addr_width-1 downto 0);
   

   attribute anyconst : boolean;

   attribute anyconst of f_addr : signal is true;

   -- Address should be word aligned.
   f_addr_aligned: assume always f_addr(1 downto 0) = "00";
                    

   -- CPU addresses are word aligned
   fa_cpu_aligned: assume always cpu_next_address(1 downto 0) = "00";


   signal f_data: std_logic_vector(cpu_data_width-1 downto 0);

   signal f_cpu_write: Boolean; -- Whether the cpu is writing to our memory location
   f_cpu_write <= cpu_next_address = f_addr and cpu_pause='0' and or_reduce(cpu_wr_byte_en)='1';

   process(all)
   begin
      if rising_edge(aclk) then
         f_data(7 downto 0) <= cpu_wr_data(7 downto 0) when f_cpu_write and cpu_wr_byte_en(0) = '1';
      	 f_data(15 downto 8) <= cpu_wr_data(15 downto 8) when f_cpu_write and cpu_wr_byte_en(1) = '1';
      	 f_data(23 downto 16) <= cpu_wr_data(23 downto 16) when f_cpu_write and cpu_wr_byte_en(2) = '1';
         f_data(31 downto 24) <= cpu_wr_data(31 downto 24) when f_cpu_write and cpu_wr_byte_en(3) = '1';
      end if;
   end process;

   -- Counts the number of words read so far from memory
   signal mem_rd_count: unsigned(word_bits_per_line downto 0) := (others => '0');
   -- Counts the number of words written so far to memory
   signal mem_wr_count: unsigned(word_bits_per_line downto 0) := (others => '0');

   process(all)
   begin
      if(rising_edge(aclk)) then
         mem_rd_count <= mem_rd_count + 1 when mem_rd_en = '1' and mem_rd_valid='1' and mem_rd_ready='1'
                         else (others => '0');
         mem_wr_count <= mem_wr_count + 1 when mem_wr_en = '1' and mem_wr_valid='1' and mem_wr_ready='1'
                         else (others => '0');
      end if;
   end process;
   
   -- Read address taking into account burst
   signal mem_rd_addr_adj : std_logic_vector(cpu_addr_width-1 downto 0);
   mem_rd_addr_adj <= std_logic_vector(unsigned(mem_rd_addr) + (mem_rd_count*4));
   -- Write address taking into account burst
   signal mem_wr_addr_adj : std_logic_vector(cpu_addr_width-1 downto 0);
   mem_wr_addr_adj <= std_logic_vector(unsigned(mem_wr_addr) + (mem_wr_count*4));


   signal f_this_return: Boolean := false; -- Whether the cache is reading from our memory location
   f_this_return <= mem_rd_en = '1' and mem_rd_addr_adj = f_addr and mem_rd_valid='1';
   signal f_mem_matches: Boolean;
   f_mem_matches <= mem_rd_data = f_data;
   fa_read_data: assume always f_this_return -> f_mem_matches;

   -- Valid signal should appear only when memory is enabled and ready
   fa_valid2: assume always ((mem_rd_valid = '1') = (mem_rd_en = '1' and mem_rd_ready = '1' and stable(mem_rd_ready)));

   -- CPU inputs do not change while pause is asserted
   fa_pause: assume always (cpu_pause -> (stable(cpu_next_address) and stable(cpu_wr_data)));
   fa_we: assume always (cpu_pause -> (cpu_wr_byte_en = "0000"));

   fa_reset_init: assume (not aresetn);
   fa_reset: assume always (f_prev_valid -> aresetn);
   fa_wr_ready: assume always mem_wr_ready = (prev(mem_wr_en and mem_wr_valid) and (mem_wr_en and mem_wr_valid));

   signal f_cpu_read: Boolean; -- Whether the CPU is trying to read our address
   f_cpu_read <= (cpu_next_address = f_addr) and (or_reduce(cpu_wr_byte_en) = '0') and (cpu_pause='0');

   f_read: assert always (f_cpu_read and f_prev_valid) -> next next_event(not cpu_pause)((cpu_rd_data = f_data));

   fa_mem_write_stable: assert always ((mem_wr_valid and mem_wr_en and stable(mem_wr_en) and not mem_wr_ready) -> (stable(mem_wr_addr) and stable(mem_wr_data) and stable(mem_wr_byte_en)));
   signal f_mem_write: Boolean; -- The cache is writing to the memory at our location
   f_mem_write <= mem_wr_valid='1' and mem_wr_en='1' and mem_wr_ready='1' and mem_wr_addr_adj = f_addr;
   f_write_mem_1: assert always (f_mem_write and mem_wr_byte_en(0)) -> ((mem_wr_data(7 downto 0) = f_data(7 downto 0)));
   f_write_mem_2: assert always (f_mem_write and mem_wr_byte_en(1)) -> ((mem_wr_data(15 downto 8) = f_data(15 downto 8)));
   f_write_mem_3: assert always (f_mem_write and mem_wr_byte_en(2)) -> ((mem_wr_data(23 downto 16) = f_data(23 downto 16)));
   f_write_mem_4: assert always (f_mem_write and mem_wr_byte_en(3)) -> ((mem_wr_data(31 downto 24) = f_data(31 downto 24)));


   -- If there is a cache hit, then the memory in the corresponding cache location should correspond to our data
   signal f_location: cache_location_t;
   signal f_index: integer;
   signal f_tag: std_logic_vector(tag_width-1 downto 0);
   signal f_offset: integer;
   f_index <= Index(f_addr);
   f_tag <= Tag(f_addr);
   f_offset <= Offset(f_addr);
   f_location <= FindInCache(f_index, f_tag);

   property f_in_cache is (f_location.hit and CacheableRange(f_addr)) -> (block_ram(to_integer(unsigned(CacheAddr(f_index, f_location.way, f_offset/4)))) = f_data);

   f_cache_data: assert always f_in_cache;

   f_mem_sigs: assert always (not mem_access_needed) -> not (mem_wr_valid or mem_wr_en or mem_rd_en or mem_rd_ready);
   f_mem_prepared: assert always ((mem_prepared -> (not cache_hit)) and (mem_access_needed -> (not mem_prepared)));

   f_one_cycle: assert always (f_location.hit and CacheableRange(f_addr)
   		       	      and cpu_next_address = f_addr and cpu_pause='0')
			      -> next (cpu_pause='0');

  c_req: cover {
     (cpu_pause = '0' and cpu_next_address=f_addr);
     {cpu_pause = '1'} [*];
     (cpu_pause = '0' and cpu_next_address/=f_addr);
     {cpu_pause = '1'} [*];
     (cpu_pause = '0' and cpu_next_address=f_addr and cpu_wr_byte_en="1111" and cpu_wr_data /= f_data);
     (cpu_pause = '0' and cpu_next_address=f_addr);
     (cpu_pause = '0' and cpu_next_address/=f_addr and Index(f_addr)=Index(cpu_next_address) and CacheableRange(cpu_next_address));
     {cpu_pause = '1'} [*];
     (cpu_pause = '0' and cpu_next_address=f_addr);
     {cpu_pause = '1'} [*];
     cpu_pause = '0'
  };

  c_uncache: cover {
    (cpu_pause = '0' and cpu_next_address=f_addr and not CacheableRange(f_addr));
    {cpu_pause = '1'} [+];
    (cpu_pause = '0' and cpu_rd_data =  f_data)
  };
}
